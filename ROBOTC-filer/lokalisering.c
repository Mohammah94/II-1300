#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//int calibration(void);
float distance[180];
float distance_control[180];
void lokalisering();
task main()
{
lokalisering();
}
void lokalisering(void)
{
	//int control;
	int copy_count;
	int index_count;
	int n = 0;
	int i;
	int j;
	float min_distance;
	int s = 5;
	float circ_Axel = 11.7;
	float circ_Wheel = 3;
	float target_rotation;
	//float dist = 10;
	//float v = 90;
	//float deg_tot = (circ_Axel/circ_Wheel) * 360;
	//float target_dist = (dist / (circ_Wheel*PI)) * 360;
	//float target_deg = (circ_Axel/circ_Wheel) * v;
	float full_rotation = (circ_Axel/circ_Wheel) * 360;

	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
	clearDebugStream();
	//Mäter avstånd
	do
	{
		setMotorSync(motorB, motorC, 100, 10);
		distance[n] = getUSDistance(S4);
		n = ((getMotorEncoder(motorB)) / (circ_Axel/circ_Wheel))/2;
	}
	while (getMotorEncoder(motorB) < full_rotation);
	setMotorSpeed(motorB,0);
	setMotorSpeed(motorC,0);
	sleep(1000);
	for(j = 0; j < 180; j++)
	{
		writeDebugStreamLine("distance[%d]=%.2f", j, distance[j]);
	}
	//Kopierar arrays
	for( copy_count = 0; copy_count < 180; ++copy_count)
	{
		distance_control[copy_count] = distance[copy_count];
  }

  //Lägger det minsta värdet först i array
	for( i = 0; i < 180; ++i)
	{
		if (distance[0] > distance[i])
		{
			distance[0] = distance[i];
		}
	}

	//Tilldelar minsta värdet till min_distance
	min_distance = distance[0];

	//Letar upp minsta värdets plats i array
	for(index_count = 0; index_count < 180; ++index_count)
		if(distance_control[index_count] == min_distance)
		{
			break;
		}
	writeDebugStreamLine("Minsta avståndet är %.2f och det har index %d", min_distance, index_count);
	target_rotation = (circ_Axel/circ_Wheel) * (index_count + 1);
	writeDebugStreamLine("Target_rotation = %.2f", target_rotation);
	//Vänder sig mot minsta avståndet
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
	do
	{
		setMotorSync(motorB, motorC, 100, 10);
	}
	while (getMotorEncoder(motorB) < target_rotation*2);
	setMotorSpeed(motorB,0);
	setMotorSpeed(motorC,0);
	sleep(1000);
}
