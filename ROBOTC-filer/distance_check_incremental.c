#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
float distance[180];
float distance_control[180];
task main()
{
	//int control;
	int copy_count;
	int index_count;
	int n = 0;
	int i;
	int j;
	float min_distance;
	int s = 10;
	float circ_Axel = 11.7;
	float circ_Wheel = 3.0;
	float deg_tot = (circ_Axel/circ_Wheel) * 360;
	float inc_deg = deg_tot/180;
	float target_deg;
	//control = calibration();
	resetGyro(S2);
	//clearDebugStream();
	//writeDebugStreamLine("%.2f", deg_tot);
	//writeDebugStreamLine("%.2f", inc_deg);

	//Mäter avstånd
	for(j = 0; j < 180; j++)
	{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
	distance[j] = getUSDistance(S4);
	sleep(100);
	setMotorSyncEncoder(motorB, motorC, 100, inc_deg, 10);
	//do
	//{
	//	setMotorSpeed(motorB, 20);
	//	setMotorSpeed(motorC, -20);
	//}
	//while(getMotorEncoder(motorB) < inc_deg);
	setMotorSpeed(motorB,0);
	setMotorSpeed(motorC,0);
	}
	//setMotorSpeed(motorB,0);
	//setMotorSpeed(motorC,0);
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
	sleep(1000);
	//for(j = 0; j < 180; j++)
	//{
	//	writeDebugStreamLine("%.2f", distance[j]);
	//}

	//Kopierar arrays
	for( copy_count = 0; copy_count < 180; ++copy_count)
	{
	distance_control[copy_count] = distance[copy_count];
	}

	//Lägger det minsta värdet först i array
	for( i = 0; i < 180; ++i)
	{
	if (distance[0] > distance[i])
	{
	distance[0] = distance[i];
	}
	}

	//Tilldelar minsta värdet till min_distance
	min_distance = distance[0];

	//Letar upp minsta värdets plats i array
	for(index_count = 0; index_count < 180; ++index_count)
	if(distance_control[index_count] == min_distance)
	{
	break;
	}
	index_count = index_count + 1;
	target_deg = (circ_Axel/circ_Wheel)*(index_count/360);
	//Vänder sig mot minsta avståndet
	//resetGyro(S2);
	setMotorSyncEncoder(motorB, motorC, 100, target_deg, 10);
	//do
	//{
	//setMotorSpeed(motorB,s);
	//setMotorSpeed(motorC,-s);
	//}
	//while (getGyroDegrees(S2) < index_count*2);
	setMotorSpeed(motorB,0);
	setMotorSpeed(motorC,0);
	sleep(1000);

}
